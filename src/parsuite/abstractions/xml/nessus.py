from parsuite.abstractions.xml.generic import network_host as NH
from parsuite.abstractions.xml.generic.network_host import Host, PortDict, PortList
from parsuite.abstractions.xml.generic.exceptions import *
from parsuite import decorators
from parsuite.helpers import slugified, AttrDict
from copy import copy
from functools import wraps
import re

plugin_name_re = pname_re = re.compile('(\s|\W)+')
ipv4_re = i4_re = re.compile('^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$')
ipv6_re = i6_re = re.compile('^(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}$')
fqdn_re = re.compile('[a-z]', re.I)

ve = decorators.validate_lxml_module

class FromXML:

    @staticmethod
    @ve
    def plugin_ids(tree) -> list:
        '''Return a list of pluginID Elements.

        Args:
            tree: lxml.etree object.
        '''

        return tree.xpath('.//@pluginID')

    # TODO: Make a generator version of this function
    @staticmethod
    @ve
    def all_report_hostnames(tree) -> dict:
        '''Return a dictionary of string hostnames organized by 
        string IP address.

        Args:
            tree: lxml.etree.ElementTree object.

        Notes:
            - This is a slow function. It iterates over all ReportHost
              elements in an effort to identify targets with the same
              IP address.
        '''

        out = {}

        for rh in tree.xpath('//ReportHost'):

            ip, hostnames = FromXML.report_host_hostnames(rh)
            out[ip] = hostnames

            rdns = rh.xpath('./tag[@name="rdns"]')
            fqdn = rh.xpath('./tag[@name="fqdn"]')

            rdns = rdns.text if rdns else None
            fqdn = fqdn.text if fqdn else None

            if rdns and rdns not in out[ip]:
                out[ip].append(rdns)

            if fqdn and fqdn not in out[ip]:
                out[ip].append(fqdn)

        return out

    @staticmethod
    @ve
    def report_host_hostnames(ereport_host) -> (str, list,):
        '''Return the str IP address and a list of str hostnames for
        an XML ReportHost element.

        Args:
            tree: lxml.etree.Element object.

        Returns:
            (str ip address, [str hostnames])

        Notes:
            - This function calls FromXML.all_report_hostnames, thus it's
            quite slow.
        '''

        host_ip = ereport_host \
            .xpath('./HostProperties/tag[@name="host-ip"]')[0] \
            .text

        hostnames = []

        for rh in ereport_host.xpath(
                '..//ReportHost/HostProperties/tag'
                '[@name="host-ip" and '
                f'text()="{host_ip}"]/../..'):

            name = rh.get('name')

            if fqdn_re.search(name):
                hostnames.append(name)

        return host_ip, hostnames

    @staticmethod
    @ve
    def report_host(ereport_host, all_hostnames=True):
        '''Generate and return a ReportHost object from an XML element
        object generated by xml.etree.ElementTree.'''

        ele = ereport_host

        kwargs = {'name':ele.get('name')}

        for attr in ReportHost.HOST_PROPERTY_ATTRIBUTES:

            for iele in ele.findall(f'./HostProperties//tag[@name="{attr}"]'):
                try:
                    kwargs[attr.replace('-','_').replace('host_','')] = iele.text
                except:
                    kwargs[attr] = None

        if all_hostnames:
            ip, kwargs['hostnames'] = FromXML.report_host_hostnames(
                    ereport_host)

        return ReportHost(**kwargs)

    @staticmethod
    @ve
    def report_item(ereport_item, report_host=None):
        '''Initialize and return a ReportItem object from an XML
        element object generated by xml.etree.
        '''

        ri = ereport_item
        raw = {}

        # Extract attribute values from the ReportItem element
        for attr in ReportItem.ATTRIBUTES:
            raw[attr] = ri.get(attr)

        # Extract text from relevant child tag elements
        for tag in ReportItem.CHILD_TAGS:
            try:
                text = ri.find(f'{tag}').text
            except:
                text = None

            raw[tag] = text

        raw['metasploit_modules'] = [
            ele.text for ele in ri.findall('.//metasploit_name')
        ]

        # Initialize and return a ReportItem objeci
        if not 'report_host' in raw:
            raw['report_host'] = report_host

        return ReportItem(**raw)

class Plugin:
    '''Represents a Nessus plugin. The name associate with a ReportItem
    and id will be bound to these objects. Facilitates easy lookups between
    ReportItems and PluginOutputDicts, the latter of which is an attribute
    of Port port objects.
    '''

    def __init__(self,name,id):

        self.name = name
        self.id = id

    def __eq__(self,value):

        if value == self.name or value == self.id:
            return True
        else:
            return False

class PluginOutputDict(dict):
    
    def append_output(self,plugin_id,output):

        if plugin_id in self:
            self[plugin_id].append(output)
        else:
            self[plugin_id] = [output]

class NessusPort(NH.Port):
    '''Override the generic NetworkHost.Port object with one that
    has a `report_items` attribute used to track ReportItem
    output for a given port.
    '''
    
    def __init__(self, plugin_outputs = PluginOutputDict(),
        *args, **kwargs):
        '''report_items is a dictionary of {plugin_id:plugin_output}.
        '''

        plugin_outputs = pluting_outputs if plugin_outputs \
            else PluginOutputDict()

        # initialize a list of report items
        self.plugin_outputs = plugin_outputs

        self.report_items = list()

        # call the parent constructor
        super().__init__(*args,**kwargs)

    @property
    def __dict__(self):

        output = super().__dict__
        output['report_items'] = list()
        if len(self.report_items) > 0:

            for ri in self.report_items:
                ri = ri.__dict__
                ri['port'] = self.number
                output['report_items'].append(ri)

        return output

Port = NessusPort

class ReportHost(NH.Host):

    HOST_PROPERTY_ATTRIBUTES = ['mac-address','operating-system',
       'netbios-name','host-fqdn','host-rdns','host-ip']

    PORT_PROTOCOLS = NH.Host.PORT_PROTOCOLS+['icmp']

    def __init__(self, name, operating_system:str=None, mac_address:str=None,
            netbios_name:str=None, rdns:str=None, ip:str=None, fqdn:str=None,
            hostnames:list=None, ports:PortList=None,
            icmp_ports:PortDict=None):

        ports = ports if ports is not None else NH.PortList()
        icmp_ports = icmp_ports if icmp_ports is not None else NH.PortDict('icmp')

        # =====================
        # INITIALIZE ATTRIBUTES
        # =====================

        self.name               = name
        self.operating_system   = operating_system
        self.mac_address        = mac_address
        self.netbios_name       = netbios_name
        self.rdns               = rdns
        self.ip                 = ip
        self.icmp_ports         = icmp_ports

        # ============================
        # INITIALIZE PARENT ATTRIBUTES
        # ============================
        
        kwargs = {}
        kwargs['status_reason'] = 'nessus-up'

        # TODO: Likely bug here.
        if re.match(ipv4_re, ip):
            kwargs['ipv4_address']=ip
        elif re.match(ipv6_re, ip):
            kwargs['ipv6_address']=ip

        hostnames = hostnames if hostnames else []

        if fqdn: hostnames.append(fqdn)
        if rdns and rdns != ip: hostnames.append(rdns)

        kwargs['hostnames'] = hostnames
        
        super().__init__(ports=ports,**kwargs)

    @property
    @slugified()
    def name_slug(self):
        return self.name

    @property
    @slugified()
    def mac_address_slug(self):
        return self.mac_address

    @property
    @slugified()
    def netbios_name_slug(self):
        return self.netbios_name

def report_item_host_exists(m):

    @wraps(m)
    def wrapper(self):

        if not hasattr(self, 'report_host'):
            return None
        elif getattr(self, 'report_host') is None:
            return None
        else:
            return m(self)

    return wrapper

class ReportItem(AttrDict):
    '''A simple object representing a ReportItem element from a 
    Nessus XML file.

    _Note_: This object varies in terms of report output. The
    Nessus XML document will associate a report item detailing
    all aspects of a given vulnerabiltity for each host, including
    details about the finding: description, plugin name, type, etc.
    This is highly inefficient in terms of memory usage, so _output
    from the plugin is not stored with a report item_. Output for
    a given report item is associated with a Port object in the
    form of `Port.report_items['plugin_id'] = ['outputs']

    '''

    # Nessus XML ReportItem attributes to track
    ATTRIBUTES = ['port','svc_name', 'protocol', 'severity','pluginID',
        'pluginName', 'pluginFamily']

    # Nessus child elements to track (text content)
    CHILD_TAGS = ['agent','always_run','description','fname',
        'plugin_modification_date', 'plugin_output',
        'plugin_publication_date', 'plugin_type', 'risk_factor',
        'script_copyright', 'script_version', 'solution',
        'synopsis', 'exploit_available',
        'exploit_framework_canvas', 'exploit_framework_metasploit',
        'exploit_framework_core', 'metasploit_name', 'canvas_package',

        'age_of_vuln', 'cve', 'cvss3_base_score', 'cvssV3_impactScore',
        'cvss_base_score', 'cvss_score_source', 'cvss_temporal_score',
        'cvss_temporal_vector', 'cvss_vector', 'msft', 'see_also'
    ]

    # Normalize XML names that are invalid or undesirable for use as
    # a python object attribute.
    NORMALIZED_MAP = dict(
        exploit_framework_canvas = 'exploit_framework_canvas',
        exploit_framework_metasploit = 'exploit_framework_metasploit',
        exploit_framework_core = 'exploit_framework_core',
        pluginID = 'plugin_id',
        pluginName = 'plugin_name',
        pluginFamily = 'plugin_family',
        cvssV3_impactScore = 'cvss3_impact_score',
        age_of_vuln = 'vuln_age',
        svc_name = 'service_name')

    NORMALIZED = []

    for a in ATTRIBUTES+CHILD_TAGS:
        if a in NORMALIZED_MAP:
            NORMALIZED.append(NORMALIZED_MAP[a])
        else:
            NORMALIZED.append(a)

    DICT_ATTRS = NORMALIZED + [
        'plugin_name_slug',
        'service_name_slug',
        'ipv4_address',
        'ipv6_address',
        'ipv4_socket',
        'ipv6_socket',
        'ipv4_url',
        'ipv6_url',
        'hostnames',
        'hostname_sockets',
        'hostname_urls']

    STANDARD_PROPERTIES = ATTRIBUTES + CHILD_TAGS

    MINIMAL_PROPERTIES = [
        v for v in STANDARD_PROPERTIES
        if v not in (
            'severity',
            'risk_factor',
            'protocol',
            'see_also',)]

    def __init__(self,
            agent:str,
            always_run:str,
            description:str,
            fname:str,
            plugin_modification_date:str,
            pluginName:str,
            plugin_publication_date:str,
            plugin_type:str,
            risk_factor:str,
            script_copyright:str,
            script_version:str,
            solution:str,
            synopsis:str,
            port:str,
            svc_name:str,
            protocol:str,
            severity:str,
            pluginID:str,
            pluginFamily:str,
            exploit_available:str,
            exploit_framework_canvas:str,
            exploit_framework_metasploit:str,
            exploit_framework_core:str,
            metasploit_name:str,
            canvas_package:str,
            plugin_output:str,
            age_of_vuln:str,
            cve:str,
            cvss3_base_score:str,
            cvssV3_impactScore:str,
            cvss_base_score:str,
            cvss_score_source:str,
            cvss_temporal_score:str,
            cvss_temporal_vector:str,
            cvss_vector:str,
            msft:str,
            see_also:str=None,
            metasploit_modules=None,
            report_host=None):

        self.report_host = report_host
        self.metasploit_modules = metasploit_modules if \
                metasploit_modules else list()
        self.exploit_frameworks = []

        # ===============
        # MANAGE THE PORT
        # ===============

        if isinstance(port, Port):

            self.port = port

        else:

            port_kwargs = dict(
                number=port,
                protocol=protocol,
                state='open',
                service=svc_name)

            self.port = Port(**port_kwargs)

        # =======================================
        # OBTAIN AND MANAGE ATTRIBUTES/CHILD TAGS
        # =======================================

        for attr in (ReportItem.ATTRIBUTES + ReportItem.CHILD_TAGS):

            if attr == 'port': continue

            #attr = RI.normalize_attr(attr)
            val = locals()[attr]
            
            if attr.startswith('exploit_framework') and val:
                self.exploit_frameworks.append(attr.split('_')[-1])

            if attr == 'risk_factor':
                val = val.lower()

            if val == 'true': val = True
            elif val == 'false': val = False

            # Set the attribute value
            setattr(self, attr, val)

        self.exploitable = self.exploit_available

        # ========================
        # SET THE TUNNEL ATTRIBUTE
        # ========================
        '''
        - Indicates SSL/TLS
        '''

        self.tunnel = False
        for k in ['ssl', 'tls']:

            tunnel = False
            if self.plugin_name.find(k) > -1 or \
                    self.plugin_name.find(k.upper()) > -1:
                tunnel = True
                self.tunnel = True

            setattr(self, k, tunnel)

        if self.svc_name == 'www':
            self.svc_name = 'http'

    @property
    def see_also(self):
        if not hasattr(self, '_see_also'):
            self._see_also = list()
        return self._see_also

    @see_also.setter
    def see_also(self, value):
        if not value:
            self._see_also = list()
        elif not isinstance(value, (str, list,)):
            raise TypeError('see_also must be a string')
        else:
            if isinstance(value, str):
                self._see_also = value.split('\n')
            else:
                self._see_also = value

    @property
    def plugin_id(self):
        return self.pluginID

    @plugin_id.setter
    def plugin_id(self, plugin_id):
        self.pluginID = plugin_id

    @property
    def plugin_name(self):
        return self.pluginName

    @plugin_name.setter
    def plugin_name(self, plugin_name):
        self.pluginName = plugin_name

    @property
    def plugin_family(self):
        return self.pluginFamily

    @plugin_family.setter
    def plugin_family(self, plugin_family):
        self.pluginFamily = plugin_family

    @property
    def cvss3_impact_score(self):
        return self.cvssV3_impactScore

    @cvss3_impact_score.setter
    def cvss3_impact_score(self, score):
        self.cvssV3_impactScore = score

    @property
    def vuln_age(self):
        return self.age_of_vuln

    @vuln_age.setter
    def vuln_age(self, age):
        self.age_of_vuln = age

    @property
    def service_name(self):
        return self.svc_name

    @service_name.setter
    def service_name(self, name):
        self.svc_name = name

    @property
    @slugified()
    def plugin_name_slug(self):
        return self.plugin_name

    @property
    @slugified()
    def plugin_name_slug(self):
        return self.plugin_name

    @property
    @slugified()
    def service_name_slug(self):
        return self.svc_name

    @staticmethod
    def normalize_attr(attr):
        '''Map a given XML attribute name back to a value that has
        been normalized (suitable for use as a Python object attribute
        name).
        '''

        if attr in ReportItem.NORMALIZED_MAP:
            return ReportItem.NORMALIZED_MAP[attr]
        else:
            return attr

    @property
    @report_item_host_exists
    def ipv4_address(self):
        return self.report_host.ipv4_address

    @property
    @report_item_host_exists
    def ipv6_address(self):
        return self.report_host.ipv6_address

    @property
    @report_item_host_exists
    def ipv4_socket(self):
        if self.report_host.ipv4_address:
            return f'{self.report_host.ipv4_address}:{self.port.number}'
        return None

    @property
    @report_item_host_exists
    def ipv6_socket(self):
        if self.report_host.ipv6_address:
            return f'[{self.report_host.ipv6_address}]:{self.port.number}'
        return None

    @property
    @report_item_host_exists
    def hostnames(self):
        if self.report_host.ipv4_address:
            return self.report_host.hostnames
        return list()

    @property
    @report_item_host_exists
    def hostname_sockets(self):
        return [
            f'{h}:{self.port.number}' for h in self.report_host.hostnames
        ]

    @property
    @report_item_host_exists
    def ipv4_url(self):
        if self.report_host.ipv4_address:
            return (f'{self.svc_name}://'
                f'{self.report_host.ipv4_address}:{self.port.number}')
        return None

    @property
    @report_item_host_exists
    def ipv6_url(self):
        if self.report_host.ipv6_address:
            return (f'{self.svc_name}://'
                f'[{self.report_host.ipv6_address}]:{self.port.number}')
        return None

    @property
    @report_item_host_exists
    def hostname_urls(self):
        return [
            f'{self.svc_name}://{h}:{self.port.number}' for h in
            self.report_host.hostnames]

    # convenience is convenient
    na = normalize_attr
    
    def additional_info(self):

        output = f'# synopsis\n\n{str(self.__getattribute__("synopsis"))}'
        for k in ['solution','description', 'plugin_type']:

            output += f'\n\n# {k}\n\n{str(self.__getattribute__(k))}'

        if self.exploit_frameworks:

            frameworks = '\n'.join(self.exploit_frameworks)
            output += f'\n\n# exploit_frameworks:\n\n{frameworks}'

        if self.metasploit_modules:

            modules = '\n'.join(self.metasploit_modules)
            output += f'\n\n# msf_modules:\n\n{modules}'

        return output+'\n'

# convenience is convenient
RI = ReportItem
